#!/usr/bin/env python3
# -*- coding:Utf-8 -*- 


"""

Auteur :      thuban <thuban@yeuxdelibad.net>  
Contributeurs : Charlène aka julianaito
licence :     MIT

Description : Manage WiFi connections on OpenBSD
Dependencies : python-tkinter-3.* for gui 

"""

import sys
import os
import re
import threading
import queue
import configparser
import locale
import subprocess 
from shlex import quote
from urllib import request
from tkinter import *
from tkinter import ttk
from tkinter import messagebox
from tkinter import simpledialog

configfile = "/etc/owi.conf"

appname = "OWi :: OpenBSD Wifi"
appurl = "https://framagit.org/Thuban/owi"
contacturl = "https://yeuxdelibad.net/Divers/Contact.html"
version = "0.5"

green="#0DC412"
yellow="#DFE619"
orange="#FFA500"
red="#FF1C1C"
font="Sans"
fontsize=10

# Translations
txt_passphrase="Passphrase required : "
txt_hiddennwid="Hidden network, enter its name: "
txt_scanning="Scanning WiFI networks"
txt_connect="Connect to WiFi"
txt_wire="Wired connexion"
txt_scan = "Scan"
txt_configuration = "Configuration"
txt_wlanlabel="WiFi interface (i.e. rtwn0) :"
txt_ethlabel="Ethernet interface (i.e. jme0) :"
txt_hidden="Hidden network"
txt_about = """
{}
{}
{}

Made with ♥ by thuban <thuban@yeuxdelibad.net>

Distributed under MIT licence

Choose a network and double-click to connect.
Right click on a network to change password.
""".format(appname, version, appurl)

try:
    LANG=locale.getdefaultlocale()[0]
    if LANG.startswith("fr"):
        txt_passphrase="Mot de passe requis : "
        txt_hiddennwid="Réseau caché, entrez son nom : "
        txt_scanning="Recherche de points d'accès WiFi"
        txt_connect="Connection au réseau WiFi"
        txt_wire="Connexion filaire"
        txt_scan = "Scanner"
        txt_configuration = "Configurer"
        txt_hidden = "Réseau caché"
        txt_about = """
{}
{}
{}

Fait avec ♥ par thuban <thuban@yeuxdelibad.net>
Distribué sous licence MIT

Choisissez un réseau puis double-cliquez dessus pour vous connecter.
Cliquez-droit sur un réseau pour changer le mot de passe.
        """.format(appname, version, appurl)
except:
    pass

### functions
def help():
    """
    print help
    """
    print("Usage : ")
    print("    {}".format(sys.argv[0]))
    print("Run the Gui to configure your Wifi")
    print("    {} -d : try to auto-connect to the strongest recognized wifi network".format(sys.argv[0]))
    print("---")
    print("You need root privileges to use this tool")
    sys.exit()

def contact(event):
    """
    Open contact url in a browser to reach the author
    """
    import webbrowser
    webbrowser.open_new("{}#encouragements".format(contacturl))

def dBmtoperc(dBm):
    """
    convert dBm to percent
    """
    dBm = int(dBm)
    if dBm <= -100 : 
        perc = 0
    elif dBm >= -55:
        perc = 100
    else:
        perc = 2 * (dBm + 100)

    return "{:3}%".format(perc)

def check_connectivity():
    """
    check if internet access
    #https://stackoverflow.com/questions/3764291/checking-network-connection
    """
    try:
        request.urlopen("http://www.openbsd.org", timeout=10)
        return True
    except Exception as e:
        print(e)
        return False

def remove_numbers(string):
    """
    remove numbers in a string
    """
    no_numbers = ""
    nn = [ c for c in string if not c.isnumeric() ]
    no_numbers = "".join(nn)

    return(no_numbers)

    
def get_ifaces():
    """list available iface"""
    ifacergx = re.compile('^(\S[a-z]+[0-9]+)')
    virtuals = ["lo", "pflog", "enc", "ppp", "tun", "bridge", "vlan", "svlan", "gre", "gif", "carp", "mpe", "vether", "trunk", "vxlan"]

    ifconfig = subprocess.Popen("/sbin/ifconfig", shell=True, stdout=subprocess.PIPE).stdout
    ifconfig = ifconfig.read().decode()

    ifacelist = []

    for l in ifconfig.splitlines():
        result = ifacergx.match(l)
        if result :
            iface = result.group(1)
            if remove_numbers(iface) not in virtuals: # don't want virtual interface
                ifacelist.append(iface)
    return(ifacelist)

def get_iface_type(iface):
    """ethernet or wlan"""
    ifconfig = subprocess.Popen("/sbin/ifconfig {}".format(iface), shell=True, stdout=subprocess.PIPE).stdout
    ifconfig = ifconfig.read().decode()

    iface_type = ""

    for l in ifconfig.splitlines():
        if l.strip().startswith("media"):
            if "Ethernet" in l :
                iface_type = "eth"
        if l.strip().startswith("groups"):
            if "wlan" in l :
                iface_type = "wlan"
        if l.startswith("urndis"):
            # USB tethering from a smartphone
            iface_type = "eth"
    return(iface_type)

def scan(iface):
    """
    scan available networks
    networks are stored in a list
    each AP is a dictionnary : { nwid, bssid, dbm, perc, sec (wpa/wep/none) }
    """

    nws = []
    nwidre = re.compile("nwid \"?(.*?)\"? chan (\d{1,3}) bssid ([a-f\d:]{17}) (-\d{1,3})dBm .+ (\S+)$")

    print("> Scanning WiFi networks")
    subprocess.Popen("/sbin/ifconfig {} up".format(iface), shell=True)
    scan = subprocess.Popen("/sbin/ifconfig {} scan".format(iface), shell=True, stdout=subprocess.PIPE).stdout
    for l in scan.readlines():
        l = l.decode().strip()
        if l.startswith("nwid"):
            try:
                nwinfos = nwidre.match(l)
                nwid = nwinfos[1]
                if nwid == "":
                    nwid = "?"
                if nwid == "0x0000000000000000000000": # hidden networks are shown this way
                    nwid = txt_hidden
                bssid = nwinfos[3]
                dbm = nwinfos[4]
                perc = dBmtoperc(dbm)
                dbm = "{} dBm".format(dbm)
                lastpart = nwinfos[5]
                if 'wpa' in lastpart:
                    sec = 'wpa'
                elif 'wep' in lastpart : 
                    sec = 'wep'
                else:
                    sec = None
                ap = { 'nwid': nwid, 'bssid': bssid, 'dbm': dbm, 'perc': perc , 'sec': sec}
                nws.append(ap)
            except Exception as e:
                print(e)
    return(nws)

def connect():
    """
    run sh /etc/netstart
    """

    with subprocess.Popen(["sh", "/etc/netstart"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, bufsize=1, universal_newlines=True) as p:
        for line in p.stdout:
            yield(line)

    yield("> Checking if connexion ok")
    if check_connectivity():
        yield("> Connected :)")
    else:
        yield("> Connexion failed")

    """
    # old way to do so
    yield("> Bringing interface down")
    os.system('/sbin/ifconfig {} down'.format(iface))
    yield("> Bringing interface up")
    os.system('/sbin/ifconfig {} up'.format(iface))
    yield("> Configuring SSID {} on {}".format(nwid,iface))

    if len(wpa) == 0:
        os.system('/sbin/ifconfig {} nwid "{}" -wpakey'.format(iface, nwid))
    else:
        os.system('/sbin/ifconfig {} nwid "{}" wpakey "{}"'.format(iface, nwid, wpa))

    yield("> Getting an IP address via DHCP")
    os.system("/sbin/dhclient {}".format(iface))
    """

def connectwired(iface):
    yield("> Bringing interface down")
    subprocess.run(['/sbin/ifconfig', iface, 'down'])
    yield("> Bringing interface up")
    subprocess.run(['/sbin/ifconfig', iface, 'up'])
    yield("> Getting an IP address via DHCP")
    subprocess.run(['/sbin/dhclient', iface])

    yield("> Checking if connexion ok")
    if check_connectivity():
        yield("> Connected :)")
    else:
        yield("> Connexion failed")

def do_hostnameif(nwid, sectype, key):
    # sectype can be False, 'wep' or 'wpa'
    nwid = quote(nwid)
    key = quote(key)
    wlaniface  = getconfig("wlaniface")
    ethiface  = getconfig("ethiface")

    with open("/etc/hostname.{}".format(wlaniface), "w") as wf:
        wf.write("up\n")
        wf.write("nwid {}\n".format(nwid))
        if not sectype:
            # no key, hostpot AP ? 
            wf.write("-wpakey \n")
            wf.write("-nwkey \n")
        elif sectype == 'wep':
            wf.write("-wpakey \n")
            wf.write("nwkey {}\n".format(key))
        elif sectype == 'wpa':
            # wpa, cool
            wf.write("wpakey {}\n".format(key))

        if not ethiface:
            wf.write("dhcp\n")
            wf.write("inet6 autoconf\n")
        else:
            with open("/etc/hostname.{}".format(ethiface), "w") as ef:
                ef.write("up\n")
            with open("/etc/hostname.trunk0", "w") as tf:
                tf.write("trunkproto failover trunkport {}\n".format(ethiface))
                tf.write("trunkport {}\n".format(wlaniface))
                tf.write("dhcp\n")
                tf.write("inet6 autoconf\n")

def auto_connect():
    """check for available AP
    connect to the most powerful known AP
    """
    wlaniface  = getconfig("wlaniface")
    if not wlaniface:
        print("no wifi interface known, please configure /etc/owi.conf")
        sys.exit()
    aplist = scan(wlaniface)
    config = configparser.ConfigParser()
    config.read(configfile)
    known_ap = config.sections()
    for ap in aplist:
        if ap['bssid'] in known_ap:
            print('> Found {} in known AP'.format(ap['nwid']))
            nwid = ap['nwid']
            wpakey = getconfig("wpa", ap['bssid'])
            do_hostnameif(nwid, wpakey)
            for l in connect():
                print(l)
            break

## Config

def getconfig(param, section="DEFAULT"):
    if not os.path.isfile(configfile):
        return False

    config = configparser.ConfigParser()
    config.read(configfile)

    if not config.has_option(section, param):
        return False

    value = config[section][param]
    return(value)


def saveconfig(section, param, value):
    config = configparser.ConfigParser()
    config.read(configfile)
    if not config.has_section(section) and section != 'DEFAULT':
        config.add_section(section)
    config[section][param] = value 
    with open(configfile, 'w') as c:
        config.write(c)
    os.chmod("/etc/owi.conf", 0o600)

## gui

def Popup(txt):
    messagebox.showinfo(message = txt)

class ConfigOwi(simpledialog.Dialog):

    def body(self, master):
        frame = ttk.Frame(master)
        titlelabel = ttk.Label(frame, text=txt_configuration)
        titlelabel.grid(sticky=N, column=0, columnspan=2, row=0, pady=5, padx=5)

        wlanlabel = ttk.Label(frame, text=txt_wlanlabel)
        wlanlabel.grid(column=0, row=1, sticky=W, pady=5, padx=5)
        wlan_ifaces = [ i for i in get_ifaces() if get_iface_type(i) == "wlan" ]
        if len(wlan_ifaces) == 0:
            Popup("No Wireless interface available")
            sys.exit(1)
        self.wlan_box_value = StringVar()
        self.wlan_box = ttk.Combobox(frame, textvariable=self.wlan_box_value)
        self.wlan_box['values'] = wlan_ifaces
        self.wlan_box.current(0)
        self.wlan_box.grid(column=1, row=1, pady=5, padx=5)

        ethlabel = ttk.Label(frame, text=txt_ethlabel)
        ethlabel.grid(column=0, row=2, sticky=W, pady=5, padx=5)
        eth_ifaces = [ i for i in get_ifaces() if get_iface_type(i) == "eth" ]
        self.eth_box_value = StringVar()
        self.eth_box = ttk.Combobox(frame, textvariable=self.eth_box_value)
        self.eth_box['values'] = eth_ifaces
        self.eth_box.current(0)
        self.eth_box.grid(column=1, row=2, pady=5, padx=5)

        for child in master.winfo_children():
            child.grid_configure(padx=5, pady=5)
        return self.wlan_box # initial focus

    def apply(self):
        wlaniface = self.wlan_box.get()
        ethiface = self.eth_box.get()
        saveconfig("DEFAULT", "wlaniface", wlaniface)
        saveconfig("DEFAULT", "ethiface", ethiface)



class Gui():

    def start(self):
        self.main()
        self.root.mainloop()

    def bgscan(self):
        self.aplist = []
        self.aplist = scan(self.wlaniface)
        self.queue.put("done")

    def scan(self):
        self.info.set(txt_scanning)
        self.p.start()
        thread = threading.Thread(target=self.bgscan)
        thread.daemon = True
        thread.start()
        self.root.after(100, self.show_ap)

    def show_ap(self):
        # clean listbox
        self.l.delete(0, END)
        try:
            msg = self.queue.get(0)
            for ap in self.aplist:
                self.l.insert('end', "{}   {}    {}".format(ap['perc'], ap['nwid'], ap['sec']))
                try:
                    perc = int(ap['perc'].replace('%',''))
                    if perc <= 100 and perc > 65:
                        bg = green
                    elif perc <= 65 and perc > 35:
                        bg = yellow
                    elif perc <= 35 and perc > 15:
                        bg = orange
                    elif perc <= 15:
                        bg = red
                except:
                    bg = "#EAFFFF"
                self.l.itemconfigure(END, background=bg)
            self.p.stop()
            self.p.grid_remove()
            self.info.set("")
        except queue.Empty:
            self.root.after(100, self.show_ap)

    def getpw(self, *args):
        if len(self.l.curselection()) == 0:
            return
        i = self.l.curselection()[0]
        nw = self.aplist[i]

        if nw['nwid'] == txt_hidden:
            # ask for hidden nwid
            nw['nwid'] = simpledialog.askstring(txt_hiddennwid,txt_hiddennwid)

        saveconfig(nw['bssid'], "nwid", nw['nwid'])
        saveconfig(nw['bssid'], "sec", nw['sec'])

        if (nw['sec'] == 'wep') or (nw['sec'] == 'wpa'):
            pw = simpledialog.askstring(txt_passphrase,txt_passphrase)
            saveconfig(nw['bssid'], "key", pw)
        self.doconnect()

    def doconnect(self,*args):
        try:
            i = self.l.curselection()[0]
        except IndexError:
            return
        nw = self.aplist[i]
        if nw['sec'] == 'wep' or nw['sec'] == 'wpa':
            key = getconfig("key",nw['bssid'])
            if not key:
                self.getpw()
        else:
            # public hotspot doesn't require password, saving it as-is
            saveconfig(nw['bssid'], "nwid", nw['nwid'])

        self.p.grid()
        self.p.start()
        self.info.set("Connecting...")
        thread = threading.Thread(target=self.guiconnect, args=(nw['bssid'],))
        thread.daemon = True
        thread.start()
        self.root.after(100, self.isconnected)

    def doconnect_wired(self,*args):
        self.p.grid()
        self.p.start()
        self.info.set("Connecting...")
        thread = threading.Thread(target=self.guiconnectwired)
        thread.daemon = True
        thread.start()
        self.root.after(100, self.isconnected)

    def guiconnect(self, bssid):
        sec = getconfig("sec", bssid)
        nwid = getconfig("nwid", bssid)
        key = getconfig("key", bssid)
        if sec == False:
            do_hostnameif(nwid, False, False)
        elif sec == 'wep':
            do_hostnameif(nwid, 'wep', key)
        elif sec == 'wpa':
            do_hostnameif(nwid, 'wpa', key)
        for message in connect():
            print(message)
            self.info.set(message)
        self.queue.put('done')

    def guiconnectwired(self):
        ethiface  = getconfig("ethiface")
        for message in connectwired(ethiface):
            print(message)
            self.info.set(message)
        self.queue.put('done')

    def isconnected(self):
        try:
            msg = self.queue.get(0)
            self.p.stop()
            self.p.grid_remove()
            self.connect_btn.config(state='normal')
        except queue.Empty:
            self.connect_btn.config(state='disabled')
            self.root.after(100, self.isconnected)

    def enable_connect_btn(self,event):
        try:
            i = self.l.curselection()[0]
            self.connect_btn.config(state='normal')
        except IndexError:
            self.connect_btn.config(state='disabled')
            return

    def askiface(self):
        ConfigOwi(self.root)
        self.wlaniface  = getconfig("wlaniface")
        self.ethiface  = getconfig("ethiface")

    def main(self):
        ttk.Sizegrip().grid(column=0, row=1, sticky=(S,E))
        self.root.grid_columnconfigure(0, weight=1)
        self.root.grid_rowconfigure(0, weight=1)

        self.mainframe = ttk.Frame(self.root, padding="3 3 12 12")
        self.mainframe.grid(column=0, row=0, sticky=(N, W, E, S))
        self.mainframe.grid_columnconfigure(0, weight=1)
        self.mainframe.grid_rowconfigure(1, weight=1)

        style = ttk.Style()
        style.theme_use("clam")
        self.root.option_add('*Dialog.msg.font', '"{}" {}'.format(font,fontsize))

        menuBtn = ttk.Frame(self.mainframe)
        menuBtn.grid(column=0, row=0, columnspan=2, sticky=E+N+W+S)

        scanBtn = ttk.Button(menuBtn, text=txt_scan, command=lambda: self.scan())
        scanBtn.grid(column=0, row=0, sticky=W)

        configBtn = ttk.Button(menuBtn, text=txt_configuration, command=lambda: self.askiface())
        configBtn.grid(column=1, row=0, sticky=W)

        aboutbtn = ttk.Button(menuBtn, text="?", command=lambda: Popup(txt_about))
        aboutbtn.grid(column=2, row=0, sticky=W)

        link = Label(menuBtn, text="    ⏣", cursor="hand2")
        link.grid(column=3,row=0,sticky=E)
        link.bind("<Button-1>", contact)

        menuBtn.columnconfigure(3, weight=1)

        self.l = Listbox(self.mainframe, height=12, width=20)
        self.l.grid(column=0, row=1, columnspan=2, sticky=(N,W,E,S))
        self.l.bind('<Button-3>', self.getpw)
        self.l.bind('<Double-Button-1>', self.doconnect)
        self.l.bind('<<ListboxSelect>>', self.enable_connect_btn)

        s = ttk.Scrollbar(self.mainframe, orient=VERTICAL, command=self.l.yview)
        s.grid(column=1, row=1, sticky=(N,S,E))
        self.l['yscrollcommand'] = s.set

        self.info = StringVar()
        self.info.set("Scanning...")
        ttk.Label(self.mainframe, textvariable=self.info).grid(column=0, row=2, sticky=(W, E))

        self.p = ttk.Progressbar(self.mainframe, mode='indeterminate', orient=HORIZONTAL)
        self.p.grid(column=0, row=3, columnspan=3, sticky=(S,W,E))

        btnBoxBtm = ttk.Frame(self.mainframe)
        btnBoxBtm.grid(column=1, row=4, sticky=E+N+S)

        self.wconnect_btn = ttk.Button(btnBoxBtm, text=txt_wire, command=self.doconnect_wired)
        self.wconnect_btn.grid(column=0, row=0,sticky=W+S)
        if not self.ethiface :
            self.wconnect_btn.config(state='disabled')

        self.connect_btn = ttk.Button(btnBoxBtm, text=txt_connect, command=self.doconnect)
        self.connect_btn.grid(column=1, row=0,sticky=E+S)
        self.connect_btn.config(state='disabled')

        for child in self.mainframe.winfo_children():
            child.grid_configure(padx=5, pady=5)

        self.root.after(10, self.scan)

    def __init__(self):
        self.queue = queue.Queue()

        self.root = Tk()
        self.root.title(appname)
        while not getconfig("wlaniface") :
            ConfigOwi(self.root)

        self.wlaniface  = getconfig("wlaniface")
        self.ethiface  = getconfig("ethiface")


def main():

    # must be root
    if os.geteuid() != 0:
        help()

    if len(sys.argv) == 1:
        app = Gui()
        app.start()
    elif len(sys.argv) == 2:
        if sys.argv[1] == "-d":
            auto_connect()
        else:
            help()
    else:
        help()
    return 0

if __name__ == '__main__':
	main()


# vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4

