#!/usr/local/bin/python3
# -*- coding:Utf-8 -*- 


"""

Auteur :      thuban <thuban@yeuxdelibad.net>  
licence :     MIT

Description : OpenBSD Package Manager
"""

import sys
import os
import locale
import subprocess 
import threading
from tkinter import *
from tkinter import ttk
from tkinter import simpledialog
from tkinter import scrolledtext 

appname = "OPaMa"
version = 0.2
appurl = "https://framagit.org/Thuban/opama"

txt_search = "Searching..."
txt_searchbox = "Search"
txt_results = "results"
txt_install = "Install"
txt_uninstall = "Uninstall"
txt_cancel = "Cancel"
txt_description = "Description"
txt_running = "Running:"
txt_installed = "Show installed packages"
txt_clean = "Remove useless packages"
txt_check = "Check for errors"
txt_installurl = "Edit installurl"
txt_mirror = "☞ Find more mirrors"
txt_simulate = "This is what will happen if you click OK. Check twice nothing will break your system"
txt_check_title = "Check system packages"
txt_check_txt = "A terminal will open to check packages on your system. Answer questions, or press ctrl-c any time to quit"
txt_about = "About"

txt_aboutfull = """
{}
{}
{}

OpenBSD Package Manager

Made with ♥ by thuban <thuban@yeuxdelibad.net>

Distributed under MIT licence
""".format(appname, version, appurl)

LANG=locale.getdefaultlocale()[0]
if not type(LANG) == str:
    print("Can't figure out used language")
    LANG=""

if LANG.startswith("fr"):
    txt_search = "Recherche..."
    txt_searchbox = "Chercher un paquet"
    txt_results = "résultat(s)"
    txt_install = "Installer"
    txt_uninstall = "Désinstaller"
    txt_cancel = "Annuler"
    txt_description = "Description"
    txt_running = "Lancement de :"
    txt_installed = "Voir les paquets installés"
    txt_clean = "Enlever les paquets inutiles"
    txt_check = "Vérifier les erreurs"
    txt_installurl = "Éditer le fichier installurl"
    txt_mirror = "☞ Trouver plus de miroirs"
    txt_simulate = "Voici une simulation de ce qui se déroulera si vous validez. Faîtes bien attention"
    txt_check_title = "Vérification des paquets"
    txt_check_txt = "Un terminal va s'ouvrir pour vérifier les paquets du système. Répondez aux questions ou pressez ctrl-c pour quitter à tout moment."
    txt_about = "À propos"

    txt_aboutfull = """
{}
{}
{}

OpenBSD Package Manager

Fait avec ♥ par thuban <thuban@yeuxdelibad.net>

Distribué sous license MIT 
""".format(appname, version, appurl)



def mirrors(event):
    import webbrowser
    webbrowser.open_new("https://www.openbsd.org/ftp.html")


class SimulateCmd:

    def __init__(self, parent, msg="",txt=""):
        self.ret = False

        top = self.top = Toplevel(parent)

        Label(top, text=msg).pack()

        self.scrolltxt = scrolledtext.ScrolledText(top)
        self.scrolltxt.pack()
        self.scrolltxt.insert(INSERT, txt)

        b = Button(top, text="OK", command=self.ok)
        b.pack(side=LEFT, padx=5, pady=5)

        c = Button(top, text=txt_cancel, command=self.cancel)
        c.pack(side=LEFT, padx=5, pady=5)

    def ok(self):
        self.top.destroy()
        self.ret = True

    def cancel(self):
        self.top.destroy()
        self.ret = False


class InstallURL(simpledialog.Dialog):
       
    def body(self, master):
        frame = ttk.Frame(master)

        self.scrolltxt = scrolledtext.ScrolledText(
            master = frame,
            wrap   = WORD,
            height=10,
        )
        self.scrolltxt.pack()

        link = Label(frame, text=txt_mirror, cursor="hand2", fg="#224488")
        link.bind("<Button-1>", mirrors)
        link.pack(padx=10, pady=10)

        if os.path.isfile('/etc/installurl'):
            with open ('/etc/installurl', 'r') as iu:
                self.scrolltxt.insert(INSERT, iu.read())

        for child in master.winfo_children():
            child.grid_configure(padx=5, pady=5)
        return self.scrolltxt #focus

    def buttonbox(self):
        # add standard button box. override if you don't want the
        # standard buttons
        box = Frame(self)

        o = ttk.Button(box, text="OK", command=self.ok, default=ACTIVE)
        o.pack(side=LEFT, padx=5, pady=5)

        c = ttk.Button(box, text=txt_cancel, command=self.cancel)
        c.pack(side=LEFT, padx=5, pady=5)

        box.pack()


    def apply(self):
        txt = self.scrolltxt.get(1.0, END)
        with open('/etc/installurl', 'w') as installurl:
            installurl.write(txt)


class PkgInfo(simpledialog.Dialog):
    def __init__(self, parent, title=None, pkg=""):
        self.pkg = pkg.replace('(installed)', '').strip()

        Toplevel.__init__(self, parent)
        self.transient(parent)

        if title:
            self.title(title)
        self.parent = parent
        self.result = None

        body = Frame(self)
        self.initial_focus = self.body(body)
        body.pack(padx=5, pady=5)

        self.buttonbox()

        if not self.initial_focus:
            self.initial_focus = self

        self.protocol("WM_DELETE_WINDOW", self.cancel)
        self.geometry("+%d+%d" % (parent.winfo_rootx()+50,
                                  parent.winfo_rooty()+50))

        self.initial_focus.focus_set()
        self.wait_window(self)

    def buttonbox(self):
        # add standard button box. override if you don't want the
        # standard buttons
        box = Frame(self)

        w = ttk.Button(box, text="OK", command=self.ok, default=ACTIVE)
        w.pack(side=LEFT, padx=5, pady=5)

        self.bind("<Return>", self.cancel)

        box.pack()

    def cancel(self, event=None):

        # put focus back to the parent window
        self.parent.focus_set()
        self.destroy()

    def body(self, master):
        frame = ttk.Frame(master)
        titlelabel = ttk.LabelFrame(frame, text=self.pkg)
        titlelabel.grid(sticky=N, column=0, columnspan=2, row=0, padx=5, pady=5)

        desc = subprocess.Popen("/usr/sbin/pkg_info {}".format(self.pkg), \
                shell=True, stdout=subprocess.PIPE).stdout
        desc = desc.read().decode()

        descLabel = ttk.Label(titlelabel, text=desc)
        descLabel.grid(padx=10, pady=10)


        for child in master.winfo_children():
            child.grid_configure(padx=5, pady=5)
        return frame # initial focus

    def apply(self):
        pass

def Popup(txt):
    from tkinter import messagebox
    messagebox.showinfo(message = txt)



class OpamaGui():
    def __init__(self):
        self.results = []
        self.issearching = False
        # main window
        self.root = Tk()

        self.root.title(appname)

        # resize window
        self.root.grid_columnconfigure(0, weight=1)
        self.root.grid_rowconfigure(0, weight=1)

        # menu button container
        menu = ttk.Frame(self.root, padding="3 3 3 3")
        menu.grid(column=0, row=0, sticky=E+W)
        for i in range(4):
            menu.grid_columnconfigure(i, weight=1)

        installed_btn = ttk.Button(menu, text=txt_installed, command=self.searchinst)
        installed_btn.grid(column=0, row=0, sticky=E+W)

        clean_btn = ttk.Button(menu, text=txt_clean, command=self.autoremove)
        clean_btn.grid(column=1, row=0, sticky=E+W)

        check_btn = ttk.Button(menu, text=txt_check, command=self.check)
        check_btn.grid(column=2, row=0, sticky=E+W)

        installurl_btn = ttk.Button(menu, text=txt_installurl, command=self.edit_installurl)
        installurl_btn.grid(column=3, row=0, sticky=E+W)

        aboutbtn = ttk.Button(menu, text=txt_about, command=lambda: Popup(txt_aboutfull))
        aboutbtn.grid(column=4, row=0, sticky=W)


        # main container
        self.mainframe = ttk.Frame(self.root, padding="3 3 12 12")
        self.mainframe.grid(column=0, row=1, sticky=N+W+E+S)
        self.mainframe.grid_columnconfigure(0, weight=1)
        
        # search entry
        searchbox = ttk.LabelFrame(self.mainframe, text=txt_searchbox)
        searchbox.grid_columnconfigure(0, weight=1)
        searchbox.grid(sticky=E+W)
        self.entry = ttk.Entry(searchbox)
        self.entry.focus_set()
        self.entry.grid(column=0, row=0, sticky=E+W, pady=5, padx=5)
        self.entry.bind("<Return>", self.search)

        okbtn = ttk.Button(searchbox, text="✓", command=self.search, width=2)
        okbtn.grid(column=1, row=0,sticky=E, padx=5, pady=3)


        # results frame in a list
        self.resultsFrame = ttk.Frame(self.mainframe)
        self.resultsFrame.grid_columnconfigure(0, weight=1)
        self.resultsFrame.grid_rowconfigure(1, weight=1)
        self.resultsFrame.grid(column=0, row=1, columnspan=2, sticky=S+N+E+W, pady=5)

        self.l = Listbox(self.resultsFrame, height=20, width=90)
        self.l.grid(column=0, row=0, columnspan=2, sticky=N+W+E+S)
        self.l.bind('<Double-Button-1>', self.show_pkg)
        self.l.bind('<<ListboxSelect>>', self.show_action_btn)

        s = ttk.Scrollbar(self.resultsFrame, orient=VERTICAL, command=self.l.yview)
        s.grid(column=1, row=0, sticky=(N,S,E))
        self.l['yscrollcommand'] = s.set

        # buttons to install/uninstall/desc

        self.action_btn_box = ttk.Frame(self.resultsFrame)
        self.action_btn_box.grid(column=0, row=1, columnspan=2, sticky=S+N+E+W)
        self.action_btn_box.grid_columnconfigure(0, weight=1)
        self.action_btn_box.grid_columnconfigure(1, weight=1)
        self.action_btn_box.grid_columnconfigure(2, weight=1)

        self.btn_install = ttk.Button(self.action_btn_box, text=txt_install, command=self.install)
        self.btn_install.grid(column=0, row=0, sticky=E+W)
        self.btn_uninstall = ttk.Button(self.action_btn_box, text=txt_uninstall, command=self.uninstall)
        self.btn_uninstall.grid(column=1,row=0, sticky=E+W)
        self.btn_description = ttk.Button(self.action_btn_box, text=txt_description, command=self.show_pkg)
        self.btn_description.grid(column=2,row=0, sticky=E+W)

        self.disable_buttons()

        # terminal box
        self.termbox = ttk.Frame(self.mainframe, height=200)
        self.termbox.grid(column=0, row=2, sticky=N+S+E+W, padx=10, pady=10)
        self.termbox.grid_columnconfigure(0, weight=1)
        self.termbox.grid_remove() # don't show term if unused

        self.instprint = scrolledtext.ScrolledText(
            master = self.termbox,
            wrap   = WORD,
            height=10,
        )

        self.instprint.grid(column=0, row=0, sticky=S+N+E+W)


        # button to show/hide term
        self.termbtn = ttk.Button(self.action_btn_box, text="▼", 
                width=2, command=self.toggletermbox)
        self.termbtn.grid(column=3, row=0, sticky=E)

        # bottom box to show info
        self.btmbox = ttk.Frame(self.mainframe)
        self.btmbox.grid(column=0, row=3, columnspan=2, sticky=S+E+W, padx=3, pady=5)
        self.btmbox.grid_columnconfigure(0, weight=1)

        self.info = ttk.Label(self.btmbox, text="")
        self.info.grid(column=0, row=0, sticky=N+S+E+W)
        self.btmbox.grid_remove()

    def toggletermbox(self):
        if len(self.termbox.grid_info()) == 0:
            self.termbox.grid()
            self.termbtn.configure(text="▲")
        else:
            self.termbox.grid_remove()
            self.termbtn.configure(text="▼")

    def start(self):
        self.root.mainloop()

    def disable_buttons(self):
        self.btn_install.config(state='disabled')
        self.btn_description.config(state='disabled')
        self.btn_uninstall.config(state='disabled')

    def searchinst(self):
        self.search(allinst=True)

    def search(self, event=None, allinst=False):
        self.disable_buttons()

        s = self.entry.get().strip()
        if len(s) > 0 or allinst:
            self.info.configure(text=txt_search)
            # clean list
            self.l.delete(0, END)

            self.issearching = True
            self.btmbox.grid()
            thread = threading.Thread(target=self.bg_search, args=(s, allinst))
            thread.daemon = True
            thread.start()

            # lock until we have finished searching
            while self.issearching :
                #self.root.update_idletasks()
                self.root.update()
                if len(self.info['text']) > 20:
                    # reset info text if too long
                    self.info.configure(text=txt_search)
                self.root.after(500,self.info.configure(text=self.info['text'] + "."))
                continue


            self.info.configure(text="{} {}".format(len(self.results), txt_results))

            if len(self.results) > 0:
                for r in self.results:
                    self.l.insert('end', r)

                # Colorize alternating lines of the listbox
                for i in range(0,len(self.results),2):
                    self.l.itemconfigure(i, background='#f0f0ff')

    def bg_search(self, sch, allinst=False):
        self.root.config(cursor="watch") # change cursor to wait
        self.root.update()

        self.results = [] # reinit
        if allinst:
            self.results = subprocess.Popen("/usr/sbin/pkg_info", \
                    shell=True, stdout=subprocess.PIPE).stdout
            self.results = self.results.read().decode()
            self.results = self.results.splitlines()
            self.results = [ "{} (installed)".format(i) for i in self.results ]
        else:
            self.results = subprocess.Popen("/usr/sbin/pkg_info -Q {}".format(sch), \
                    shell=True, stdout=subprocess.PIPE).stdout
            self.results = self.results.read().decode()
            self.results = self.results.splitlines()

        self.issearching = False
        self.root.config(cursor="") # change cursor to wait


    def show_pkg(self, evt=None):
        i = self.l.curselection()[0]
        pkg = self.results[i].split(' ')[0]
        PkgInfo(parent=self.root, title=pkg, pkg=pkg)

    def show_action_btn(self, evt):
        try:
            i = self.l.curselection()[0]
            pkg = self.results[i]
            self.btn_description.config(state='normal')
            if '(installed)' in pkg:
                self.installed = True
                self.btn_uninstall.config(state='normal')
                self.btn_install.config(state='disabled')
            else : 
                self.installed = False
                self.btn_install.config(state='normal')
                self.btn_uninstall.config(state='disabled')
        except IndexError: #no more selected
            self.btn_install.config(state='disabled')
            self.btn_uninstall.config(state='disabled')
            self.btn_description.config(state='disabled')


    def install(self):
        i = self.l.curselection()[0]
        pkg = self.results[i].split(' ')[0]
        cmd = "pkg_add -Ixv {}".format(pkg)

        self.termbox.grid()

        thread = threading.Thread(target=self.exec_and_show, args=(cmd,))
        thread.daemon = True
        thread.start()

    def uninstall(self):
        i = self.l.curselection()[0]
        pkg = self.results[i].split(' ')[0]
        pkg = pkg.replace('(installed)', '').strip()
        cmd = "pkg_delete -Ixv {}".format(pkg)

        self.termbox.grid()

        thread = threading.Thread(target=self.exec_and_show, args=(cmd,))
        thread.daemon = True
        thread.start()

    def autoremove(self):
        self.root.config(cursor="watch") # change cursor to wait
        self.root.update()
        output = subprocess.check_output('pkg_delete -aIxvn', shell=True)
        s = SimulateCmd(self.root, txt_simulate, output)
        self.root.wait_window(s.top)
        self.root.config(cursor="") # change cursor to normal

        if s.ret == True:
            self.termbox.grid()

            cmd = "pkg_delete -aIxv"
            thread = threading.Thread(target=self.exec_and_show, args=(cmd,))
            thread.daemon = True
            thread.start()

    def check(self):
        from tkinter import messagebox
        messagebox.showwarning(title=txt_check_title, message=txt_check_txt, parent=self.root)
        self.root.withdraw()
        cmd = 'xterm -sb -bg black -fg grey -fa "Hack" -fs 10 \
                -e "echo Check packages && pkg_check -v"'
        subprocess.run(cmd, shell=True)
        self.root.update()
        self.root.deiconify()

    def exec_and_show(self,cmd):
        self.instprint.insert(INSERT, "\n{} {}\n---\n".format(txt_running, cmd))
        cmd = cmd.split(' ')
        
        for message in exec_cmd(cmd):
            print(message)
            self.instprint.insert(INSERT, message)
        self.instprint.insert(INSERT, "✓ done")

        # update list once done
        self.search()

    def edit_installurl(self):
        InstallURL(parent=self.root)


def exec_cmd(cmd):
    # cmd must be a list
    with subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, bufsize=1, universal_newlines=True) as p:
        for line in p.stdout:
            yield(line)


def main():
    if os.geteuid() != 0:
        print('You must have root privileges')
        sys.exit(0)

    o = OpamaGui()
    o.start()

    return 0

if __name__ == '__main__':
	main()


# vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4

