#!/usr/local/bin/python3
# -*- coding:Utf-8 -*- 


"""

Auteur :      thuban <thuban@yeuxdelibad.net>  
licence :     MIT

Description : Manage WiFi connections on OpenBSD
Dependencies : python-tkinter-3.4.5 for gui 

"""

import sys
import os
import re
import threading
import queue
import configparser
from subprocess import Popen,PIPE,STDOUT
from urllib import request
from tkinter import *
from tkinter import ttk
from tkinter import messagebox

configfile = "/etc/owi.conf"

appname = "OWi :: OpenBSD Wifi"
version = "0.1"
abouttxt = """
{}
{}
---
Made with love by thuban <thuban@yeuxdelibad.net>

Distributed under MIT licence
---
Choose a network and double-click to connect.
Right click on a network to change password.
""".format(appname, version)


### functions

def help():
    """
    print help
    """
    print("Usage : ")
    print("    {}".format(sys.argv[0]))
    print("Run the Gui to configure your Wifi")
    print("    {} -d : try to auto-connect to the strongest recognized wifi network".format(sys.argv[0]))
    print("---")
    print("You need root privileges to use this tool")
    sys.exit()

def dBmtoperc(dBm):
    """
    convert dBm to percent
    """
    dBm = int(dBm)
    if dBm <= -100 : 
        perc = 0
    elif dBm >= -55:
        perc = 100
    else:
        perc = 2 * (dBm + 100)

    return "{:3}%".format(perc)

def check_connectivity():
    """
    check if internet access
    #https://stackoverflow.com/questions/3764291/checking-network-connection
    """
    try:
        request.urlopen("http://www.openbsd.org", timeout=10)
        return True
    except Exception as e:
        print(e)
        return False

def remove_numbers(string):
    """
    remove numbers in a string
    """
    no_numbers = ""
    nn = [ c for c in string if not c.isnumeric() ]
    no_numbers = "".join(nn)

    return(no_numbers)

    
def get_ifaces():
    """list avaiable iface"""
    ifacergx = re.compile('^(\S[a-z]+[0-9]+)')
    virtuals = ["lo", "pflog", "enc", "ppp", "tun", "bridge", "vlan", "svlan", "gre", "gif", "carp", "mpe", "vether", "trunk", "vxlan"]

    ifconfig = Popen("/sbin/ifconfig", shell=True, stdout=PIPE).stdout
    ifconfig = ifconfig.read().decode()

    ifacelist = []

    for l in ifconfig.splitlines():
        result = ifacergx.match(l)
        if result :
            iface = result.group(1)
            if remove_numbers(iface) not in virtuals:
                ifacelist.append(iface)
    return(ifacelist)

def get_iface_type(iface):
    """ethernet or wlan"""
    ifconfig = Popen("/sbin/ifconfig {}".format(iface), shell=True, stdout=PIPE).stdout
    ifconfig = ifconfig.read().decode()

    iface_type = ""

    for l in ifconfig.splitlines():
        if l.strip().startswith("media"):
            if "Ethernet" in l :
                iface_type = "eth"
        if l.strip().startswith("groups"):
            if "wlan" in l :
                iface_type = "wlan"
    return(iface_type)

def scan(iface):
    """
    scan avaiable networks
    networks are stored in a list
    each AP is a dictionnary : { nwid, bssid, dbm, perc }
    """

    nws = []

    print("> Scanning WiFi networks")
    scan = Popen("/sbin/ifconfig {} scan".format(iface), shell=True, stdout=PIPE).stdout
    for l in scan.readlines():
        l = l.decode().strip()
        if l.startswith("nwid"):
            try:
                if not "wpa" in l:
                    continue
                nwid = l.split('nwid')[1]
                if '"' in nwid:
                    nwid = nwid.split('"')[1]
                else:
                    nwid = nwid.split(' ')[1]
                if nwid == "":
                    nwid = "?"
                # chan = l.split('chan')[1].split(' ')[1]
                bssid = l.split('bssid')[1].split(' ')[1]
                dbm = l.split('bssid')[1].split(' ')[2].replace('dBm', '')
                perc = dBmtoperc(dbm)
                dbm = "{} dBm".format(dbm)
                ap = { 'nwid': nwid, 'bssid': bssid, 'dbm': dbm, 'perc': perc }
                nws.append(ap)
            except Exception as e:
                print(e)
    return(nws)

def connect():
    """
    run sh /etc/netstart
    """

    with Popen(["sh", "/etc/netstart"], stdout=PIPE, stderr=STDOUT, bufsize=1, universal_newlines=True) as p:
        for line in p.stdout:
            yield(line)

    yield("> Checking if connexion ok")
    if check_connectivity():
        yield("> Connected :)")
    else:
        yield("> Connexion failed")

    """
    # old way to do so
    yield("> Bringing interface down")
    os.system('/sbin/ifconfig {} down'.format(iface))
    yield("> Bringing interface up")
    os.system('/sbin/ifconfig {} up'.format(iface))
    yield("> Configuring SSID {} on {}".format(nwid,iface))

    if len(wpa) == 0:
        os.system('/sbin/ifconfig {} nwid "{}" -wpakey'.format(iface, nwid))
    else:
        os.system('/sbin/ifconfig {} nwid "{}" wpakey "{}"'.format(iface, nwid, wpa))

    yield("> Getting an IP address via DHCP")
    os.system("/sbin/dhclient {}".format(iface))
    """

def do_hostnameif(nwid, wpakey):
    wlaniface  = getconfig("wlaniface")
    ethiface  = getconfig("ethiface")

    with open("/etc/hostname.{}".format(wlaniface), "w") as wf:
        wf.write("up\n")
        wf.write("nwid {}\n".format(nwid))
        wf.write("wpakey {}\n".format(wpakey))
        if not ethiface:
            wf.write("dhcp\n")
            wf.write("rtsol\n")
        else:
            with open("/etc/hostname.{}".format(ethiface), "w") as ef:
                ef.write("up\n")
            with open("/etc/hostname.trunk0", "w") as tf:
                tf.write("trunkproto failover trunkport {}\n".format(ethiface))
                tf.write("trunkport {}\n".format(wlaniface))
                tf.write("dhcp\n")
                tf.write("rtsol\n")

def auto_connect():
    """check for avaiable AP
    connect to the most powerful known AP
    """
    wlaniface  = getconfig("wlaniface")
    if not wlaniface:
        print("no wifi interface known, please configure /etc/owi.conf")
        sys.exit()
    aplist = scan(wlaniface)
    config = configparser.ConfigParser()
    config.read(configfile)
    known_ap = config.sections()
    for ap in aplist:
        if ap['bssid'] in known_ap:
            print('> Found {} in known AP'.format(ap['nwid']))
            nwid = ap['nwid']
            wpakey = getconfig("wpa", ap['bssid'])
            do_hostnameif(nwid, wpakey)
            for l in connect():
                print(l)
            break

## Config

def getconfig(param, section="DEFAULT"):
    if not os.path.isfile(configfile):
        return False

    config = configparser.ConfigParser()
    config.read(configfile)

    if not section in config:
        return False

    value = config[section][param]
    return(value)


def saveconfig(section, param, value):
    config = configparser.ConfigParser()
    config.read(configfile)
    if not config.has_section(section) and section != 'DEFAULT':
        config.add_section(section)
    config[section][param] = value 
    with open(configfile, 'w') as c:
        config.write(c)

## gui

def Popup(txt):
    messagebox.showinfo(message = txt)

class Gui():

    def askiface(self,*args):
        self.wlaniface = self.wlan_box.get()
        self.ethiface = self.wlan_box.get()
        saveconfig("DEFAULT", "wlaniface", self.wlaniface)
        saveconfig("DEFAULT", "ethiface", self.ethiface)
        self.clean()
        self.main()

    def clean(self):
        for child in self.mainframe.winfo_children():
            child.destroy()

    def start(self):
        if not self.wlaniface: 
            titlelabel = ttk.Label(self.mainframe, text="Configuration :")
            titlelabel.grid(sticky=N, column=0, columnspan=2, row=0, pady=5, padx=5)

            wlanlabel = ttk.Label(self.mainframe, text="WiFi interface (i.e. rtwn0) :")
            wlanlabel.grid(column=0, row=1, sticky=W, pady=5, padx=5)
            wlan_ifaces = [ i for i in get_ifaces() if get_iface_type(i) == "wlan" ]
            self.wlan_box_value = StringVar()
            self.wlan_box = ttk.Combobox(self.mainframe, textvariable=self.wlan_box_value)
            self.wlan_box['values'] = wlan_ifaces
            self.wlan_box.current(0)
            self.wlan_box.grid(column=1, row=1, pady=5, padx=5)

            ethlabel = ttk.Label(self.mainframe, text="Ethernet interface (i.e. jme0) :")
            ethlabel.grid(column=0, row=2, sticky=W, pady=5, padx=5)
            eth_ifaces = [ i for i in get_ifaces() if get_iface_type(i) == "eth" ]
            self.eth_box_value = StringVar()
            self.eth_box = ttk.Combobox(self.mainframe, textvariable=self.eth_box_value)
            self.eth_box['values'] = eth_ifaces
            self.eth_box.current(0)
            self.eth_box.grid(column=1, row=2, pady=5, padx=5)

            ttk.Button(self.mainframe, text="OK", command=self.askiface).grid(column=0, row=3, columnspan=2,sticky=S, pady=7, padx=7)
            self.root.bind('<Return>', self.askiface)
        else:
            self.main()

        style = ttk.Style()
        style.theme_use("clam")
        self.root.mainloop()

    def bgscan(self):
        self.aplist = scan(self.wlaniface)
        self.queue.put("done")

    def scan(self):
        self.info.set("Scanning...")
        self.p.start()
        thread = threading.Thread(target=self.bgscan)
        thread.daemon = True
        thread.start()
        self.root.after(100, self.show_ap)

    def show_ap(self):
        try:
            msg = self.queue.get(0)
            for ap in self.aplist:
                self.l.insert('end', "{}   {}".format(ap['perc'], ap['nwid']))
            self.p.stop()
            self.p.grid_remove()
            self.info.set("")
        except queue.Empty:
            self.root.after(100, self.show_ap)

    def getpw(self, *args):
        passphrase = self.pw.get()
        i = self.l.curselection()[0]
        nw = self.aplist[i]
        saveconfig(nw['bssid'], "nwid", nw['nwid'])
        saveconfig(nw['bssid'], "wpa", passphrase)
        self.t.destroy()
        self.doconnect()

    def getpwgui(self, *args):
        if len(self.l.curselection()) == 0:
            return
        self.t = Toplevel(self.root)
        self.pw = StringVar()
        ttk.Label(self.t, text="Passphrase required").grid(column=0, row=0, sticky=(W, E))
        entry = ttk.Entry(self.t, width=16, textvariable=self.pw)
        entry.grid(column=1, row=0, sticky=(W, E))
        ttk.Button(self.t, text="OK", command=self.getpw).grid(column=2, row=0, sticky=W)
        entry.focus()
        self.t.bind('<Return>', self.getpw)
        for child in self.t.winfo_children():
            child.grid_configure(padx=5, pady=5)

    def doconnect(self,*args):
        try:
            i = self.l.curselection()[0]
        except IndexError:
            return
        nw = self.aplist[i]
        passphrase = getconfig("wpa",nw['bssid'])

        if not passphrase:
            self.getpwgui()
        else: 
            self.p.grid()
            self.p.start()
            self.info.set("Connecting...")
            thread = threading.Thread(target=self.guiconnect, args=(nw['nwid'], passphrase))
            thread.daemon = True
            thread.start()
            self.root.after(100, self.isconnected)

    def guiconnect(self, nwid, wpa):
        do_hostnameif(nwid, wpa)
        for message in connect():
            print(message)
            self.info.set(message)
        self.queue.put('done')

    def isconnected(self):
        try:
            msg = self.queue.get(0)
            self.p.stop()
            self.p.grid_remove()
            self.connect_btn.config(state='normal')
        except queue.Empty:
            self.connect_btn.config(state='disabled')
            self.root.after(100, self.isconnected)

    def enable_connect_btn(self,event):
        try:
            i = self.l.curselection()[0]
            self.connect_btn.config(state='normal')
        except IndexError:
            self.connect_btn.config(state='disabled')
            return

    def main(self):

        self.l = Listbox(self.mainframe, height=9, width=35)
        self.l.grid(column=0, row=0, columnspan=2, sticky=(N,W,E,S))
        self.l.bind('<Button-3>', self.getpwgui)
        self.l.bind('<Double-Button-1>', self.doconnect)
        self.l.bind('<<ListboxSelect>>', self.enable_connect_btn)

        s = ttk.Scrollbar(self.mainframe, orient=VERTICAL, command=self.l.yview)
        s.grid(column=1, row=0, sticky=(N,S,E))
        self.l['yscrollcommand'] = s.set

        self.info = StringVar()
        self.info.set("Scanning...")
        self.p = ttk.Progressbar(self.mainframe, mode='indeterminate', orient=HORIZONTAL)
        self.p.grid(column=0, row=2, columnspan=3, sticky=(S,W,E))

        ttk.Label(self.mainframe, textvariable=self.info).grid(column=0, row=1, sticky=(W, E))

        aboutbtn = ttk.Button(self.mainframe, text="?", command=lambda: Popup(abouttxt))
        aboutbtn.grid(column=0, row=3, sticky=W)

        self.connect_btn = ttk.Button(self.mainframe, text="Connect", command=self.doconnect)
        self.connect_btn.grid(column=1, row=3, sticky=E)
        self.connect_btn.config(state='disabled')

        for child in self.mainframe.winfo_children():
            child.grid_configure(padx=5, pady=5)

        self.root.after(10, self.scan)

    def __init__(self):
        self.wlaniface  = getconfig("wlaniface")
        self.ethiface  = getconfig("ethiface")
        self.queue = queue.Queue()

        self.root = Tk()
        self.root.title(appname)

        ttk.Sizegrip().grid(column=0, row=1, sticky=(S,E))
        self.root.grid_columnconfigure(0, weight=1)
        self.root.grid_rowconfigure(0, weight=1)

        self.mainframe = ttk.Frame(self.root, padding="3 3 12 12")
        self.mainframe.grid(column=0, row=0, sticky=(N, W, E, S))
        self.mainframe.grid_columnconfigure(0, weight=1)
        self.mainframe.grid_rowconfigure(0, weight=1)


def main():

    # must be root
    if os.geteuid() != 0:
        help()

    if len(sys.argv) == 1:
        app = Gui()
        app.start()
    elif len(sys.argv) == 2:
        if sys.argv[1] == "-d":
            auto_connect()
        else:
            help()
    else:
        help()
    return 0

if __name__ == '__main__':
	main()


# vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4

